; OpenRISC Basic Instruction Set 32-bit (ORBIS32)  -*- Scheme -*-
; Copyright 2000, 2001, 2011 Free Software Foundation, Inc.
; Contributed by Johan Rydberg, jrydberg@opencores.org
; Modified by Julius Baxter, juliusbaxter@gmail.com
; Modified by Peter Gavin, pgavin@gmail.com

; Instruction fields.

; Attributes:
;  . PCREL-ADDR  pc relative value (for reloc and disassembly purposes)
;  . RESERVED    bits are not used to decode insn, must be all 0

; Hardware for immediate operands
(dnh h-simm16 "16-bit signed immediate" () (immediate (INT 16)) () () ())
(dnh h-uimm16 "16-bit unsigned immediate" () (immediate (UINT 16)) () () ())
(dnh h-uimm6  "6-bit unsigned immediate" () (immediate (UINT 6)) () () ())

; Instruction classes.
(dnf f-opcode     "insn opcode"          () 31 6)

; Register fields.
(dnf f-r1        "r1"                  () 25 5)
(dnf f-r2        "r2"                  () 20 5)
(dnf f-r3        "r3"                  () 15 5)

; Sub fields
(dnf f-op-25-2       "op-25-2"              () 25 2) ;; nop
(dnf f-op-25-5       "op-25-5"              () 25 5) ;; sys, trap, *sync, sf*
(dnf f-op-16-1       "op-16-1"              () 16 1) ;; movhi,macrc
(dnf f-op-7-4        "op-7-4"               () 7 4)
(dnf f-op-3-4        "op-3-4"               () 3 4)
(dnf f-op-9-2        "op-9-2"               () 9 2) ;; alu ops upper opcode
(dnf f-op-9-4        "op-9-4"               () 9 4) ;;
(dnf f-op-7-8        "op-7-8"               () 7 8)
(dnf f-op-7-2        "op-7-2"               () 7 2) ;; alu lower upper opc,shroti

; Reserved fields
(dnf f-resv-25-26       "resv-25-26"              () 25 26)
(dnf f-resv-25-10       "resv-25-10"              () 25 10)
(dnf f-resv-23-8        "resv-23-8"               () 23 8)
(dnf f-resv-20-5        "resv-20-5"               () 20 5)
(dnf f-resv-20-4        "resv-20-4"               () 20 4)
(dnf f-resv-15-8        "resv-15-8"               () 15 8)
(dnf f-resv-15-6        "resv-15-6"               () 15 6)
(dnf f-resv-10-11       "resv-10-11"              () 10 11)
(dnf f-resv-10-7        "resv-10-7"               () 10 7)
(dnf f-resv-10-3        "resv-10-3"               () 10 3)
(dnf f-resv-10-1        "resv-10-1"               () 10 1)
(dnf f-resv-7-4         "resv-7-4"                () 7 4)
(dnf f-resv-5-2         "resv-5-2"                () 5 2)

(dnf f-imm16-25-5       "imm16-25-5"              () 25  5)
(dnf f-imm16-10-11      "imm16-10-11"             () 10 11)

; PC relative, 26-bit (2 shifted to right)
(df f-disp26     "disp26"              (PCREL-ADDR) 25 26 INT
    ((value pc) (sra WI (sub WI value pc) (const 2)))
    ((value pc) (add WI (sll WI value (const 2)) pc)))

; Immediates.
(dnf f-uimm16    "uimm16"                ()         15 16)
(df  f-simm16    "simm16"                (SIGN-OPT) 15 16 INT #f #f)
(dnf f-uimm6     "uimm6"                 ()         5  6) ;; shroti

(define-multi-ifield
  (name f-uimm16-split)
  (comment "16-bit split unsigned immediate")
  (mode UINT)
  (subfields f-imm16-25-5 f-imm16-10-11)
  (insert (sequence ()
                    (set (ifield f-imm16-25-5)
                         (and (srl (ifield f-uimm16-split)
                                   (const 11))
                              (const #x1f)))
                    (set (ifield f-imm16-10-11)
                         (and (ifield f-uimm16-split)
                              (const #x7ff)))))
  (extract (sequence ()
                     (set (ifield f-uimm16-split)
                          (zext UWI (trunc UHI
                                         (or (sll (ifield f-imm16-25-5)
                                                  (const 11))
                                             (ifield f-imm16-10-11)))))))
  )

(define-multi-ifield
  (name f-simm16-split)
  (comment "16-bit split signed immediate")
  (attrs SIGN-OPT)
  (mode INT)
  (subfields f-imm16-25-5 f-imm16-10-11)
  (insert (sequence ()
                    (set (ifield f-imm16-25-5)
                         (and (sra (ifield f-simm16-split)
                                   (const 11))
                              (const #x1f)))
                    (set (ifield f-imm16-10-11)
                         (and (ifield f-simm16-split)
                              (const #x7ff)))))
  (extract (sequence ()
                     (set (ifield f-simm16-split)
                          (ext WI (trunc HI
                                         (or (sll (ifield f-imm16-25-5)
                                                  (const 11))
                                             (ifield f-imm16-10-11)))))))
  )


; Enums.

; insn-opcode: bits 31-26
(define-normal-insn-enum 
  insn-opcode "insn main opcode enums" () OPC_ f-opcode
  (("J" #x00 )
   ("JAL" #x01 )
   ("BNF" #x03 )
   ("BF" #x04 )
   ("NOP" #x05)
   ("MOVHIMACRC" #x06)
   ("SYSTRAPSYNCS" #x08)
   ("RFE" #x09)
   ("VECTOR" #x0a)
   ("JR" #x11)
   ("JALR" #x12 )
   ("MACI" #x13)
   ("CUST1" #x1c)
   ("CUST2" #x1d)
   ("CUST3" #x1e)
   ("CUST4"#x1f)
   ("LD" #x20)
   ("LWZ" #x21)
   ("LWS" #x22)
   ("LBZ" #x23)
   ("LBS" #x24)
   ("LHZ" #x25)
   ("LHS" #x26)
   ("ADDI" #x27)
   ("ADDIC" #x28)
   ("ANDI" #x29)
   ("ORI" #x2a)
   ("XORI" #x2b)
   ("MULI" #x2c)
   ("MFSPR" #x2d)
   ("SHROTI" #x2e)
   ("SFI"  #x2f)
   ("MTSPR" #x30)
   ("MAC" #x31)
   ("FLOAT" #x32)
   ("SD" #x34)
   ("SW" #x35)
   ("SB" #x36)
   ("SH" #x37)
   ("ALU" #x38)
   ("SF" #x39)
   ("CUST5" #x3c)
   ("CUST6" #x3d)
   ("CUST7" #x3e)
   ("CUST8" #x3f ) 
  )
)

(define-normal-insn-enum insn-opcode-systrapsyncs 
  "systrapsync insn opcode enums" () 
  OPC_SYSTRAPSYNCS_ f-op-25-5
    (("SYSCALL" #x00 )
     ("TRAP" #x08 )
     ("MSYNC" #x10 )
     ("PSYNC" #x14 )
     ("CSYNC" #x18 )
    )
)

(define-normal-insn-enum insn-opcode-movehimacrc
  "movhi/macrc insn opcode enums" () 
  OPC_MOVHIMACRC_ f-op-16-1
  (("MOVHI" #x0)
   ("MACRC" #x1)
  )
)

(define-normal-insn-enum insn-opcode-mac
  "multiply/accumulate insn opcode enums" ()
  OPC_MAC_ f-op-3-4
  (("MAC" #x1)
   ("MSB" #x2)
   )
  )

(define-normal-insn-enum insn-opcode-shorts 
  "shift/rotate insn opcode enums" () 
  OPC_SHROTS_ f-op-7-2
    (("SLL" #x0 )
     ("SRL" #x1 )
     ("SRA" #x2 )
     ("ROR" #x3 )
    )
)

(define-normal-insn-enum insn-opcode-extbhs
  "extend byte/half opcode enums" ()
  OPC_EXTBHS_ f-op-9-4
  (("EXTHS" #x0)
   ("EXTBS" #x1)
   ("EXTHZ" #x2)
   ("EXTBZ" #x3)
   )
)

(define-normal-insn-enum insn-opcode-extws
  "extend word opcode enums" ()
  OPC_EXTWS_ f-op-9-4
  (("EXTWS" #x0)
   ("EXTWZ" #x1)
   )
)

(define-normal-insn-enum insn-opcode-alu-regreg 
  "alu reg/reg insn opcode enums" () 
  OPC_ALU_REGREG_ f-op-3-4
  (("ADD"   #x0)
   ("ADDC"  #x1)
   ("SUB"   #x2)
   ("AND"   #x3)
   ("OR"    #x4)
   ("XOR"   #x5)
   ("MUL"   #x6)
   ("SHROT" #x8)
   ("DIV"   #x9)
   ("DIVU"  #xA)
   ("MULU"  #xB)
   ("EXTBH" #xC)
   ("EXTW"  #xD)
   ("CMOV"  #xE)
   ("FFL1"  #xF)
   )
)

(define-normal-insn-enum insn-opcode-setflag
  "setflag insn opcode enums" () 
  OPC_SF_ f-op-25-5
    (("EQ"  #x00)
     ("NEQ" #x01)
     ("GTU" #x02)
     ("GEU" #x03)
     ("LTU" #x04)
     ("LEU" #x05)
     ("GTS" #x0A)
     ("GES" #x0B)
     ("LTS" #x0C)
     ("LES" #x0D)
    )
)


; Instruction operands.

(dnop sys-sr       "supervision register"                  (SEM-ONLY) h-sys-sr       f-nil)
(dnop sys-esr0     "exception supervision register 0"      (SEM-ONLY) h-sys-esr0     f-nil)
(dnop sys-epcr0    "exception PC register 0"               (SEM-ONLY) h-sys-epcr0    f-nil)

(dnop sys-sr-f     "SR flag bit"                           (SEM-ONLY) h-sys-sr-f     f-nil)
(dnop sys-sr-cy    "SR carry bit"                          (SEM-ONLY) h-sys-sr-cy    f-nil)
(dnop sys-sr-ov    "SR overflow bit"                       (SEM-ONLY) h-sys-sr-ov    f-nil)
(dnop sys-fpcsr-rm "floating point round mode"             (SEM-ONLY) h-sys-fpcsr-rm f-nil)

(dnop mac-machi    "MAC HI result register"                (SEM-ONLY) h-mac-machi    f-nil)
(dnop mac-maclo    "MAC LO result register"                (SEM-ONLY) h-mac-maclo    f-nil)

(dnop disp26       "pc-rel 26 bit"                         ()         h-iaddr        f-disp26)
(dnop uimm6        "uimm6"                                 ()         h-uimm6        f-uimm6)

(dnop rD           "destination register"                  ()         h-gr           f-r1)
(dnop rA           "source register A"                     ()         h-gr           f-r2)
(dnop rB           "source register B"                     ()         h-gr           f-r3)

(define-operand
  (name simm16)
  (comment "16-bit signed immediate")
  (attrs SIGN-OPT)
  (type h-simm16)
  (index f-simm16)
  (handlers (parse "simm16"))
  )

(define-operand
  (name uimm16)
  (comment "16-bit unsigned immediate")
  (attrs)
  (type h-uimm16)
  (index f-uimm16)
  (handlers (parse "uimm16"))
  )

(define-operand
  (name simm16-split)
  (comment "split 16-bit signed immediate")
  (attrs SIGN-OPT)
  (type h-simm16)
  (index f-simm16-split)
  (handlers (parse "simm16"))
)

(define-operand
  (name uimm16-split)
  (comment "split 16-bit unsigned immediate")
  (attrs)
  (type h-uimm16)
  (index f-uimm16-split)
  (handlers (parse "uimm16"))
)

; Instructions.

; Branch releated instructions 

(dni l-j "jump (pc-relative iaddr)"
     ; This function may not be in delay slot
     ((MACH ORBIS32-MACHS) NOT-IN-DELAY-SLOT) 

     "l.j ${disp26}"
     (+ OPC_J disp26)

     ; We execute the delay slot before doin' the real branch
     (delay 1 (set pc disp26))
     ()
)

(dni l-jal "jump and link (pc-relative iaddr)"
     ; This function may not be in delay slot
     ((MACH ORBIS32-MACHS) NOT-IN-DELAY-SLOT)

     "l.jal ${disp26}"
     (+ OPC_JAL disp26)

     ; We execute the delay slot before doin' the real branch
     ; Set LR to (delay insn addr + 4)
     (sequence ()
               (set (reg h-gr 9) (add (reg h-delay-insn) 4))
               (delay 1 (set pc disp26)))
     ()
)

(dni l-jr "jump register (absolute iaddr)"
     ; This function may not be in delay slot
     ((MACH ORBIS32-MACHS) NOT-IN-DELAY-SLOT)

     "l.jr $rB"
     (+ OPC_JR (f-resv-25-10 0) rB (f-resv-10-11 0))

     ; We execute the delay slot before doin' the real branch
     (delay 1 (set pc rB))
     ()
)

(dni l-jalr "jump register and link (absolute iaddr)"
     ; This function may not be in delay slot
     ((MACH ORBIS32-MACHS) NOT-IN-DELAY-SLOT)

     "l.jalr $rB"
     (+ OPC_JALR (f-resv-25-10 0) rB (f-resv-10-11 0) )

     ; We save the value of rB in a temporary slot before setting
     ; the link register.  This because "l.jalr r9" would cause
     ; a forever-and-ever loop otherwise.
     ;
     ; We execute the delay slot before doin' the real branch
     (sequence ((WI tmp-slot))
               (set tmp-slot rB)
               (set (reg h-gr 9) (add (reg h-delay-insn) 4))
               (delay 1 (set pc tmp-slot)))
     ()
)

(dni l-bnf "branch if condition bit not set (pc relative iaddr)"
     ; This function may not be in delay slot
     ((MACH ORBIS32-MACHS) NOT-IN-DELAY-SLOT)

     "l.bnf ${disp26}"
     (+ OPC_BNF disp26)

     ; We execute the delay slot before doin' the real branch
     (if (eq sys-sr-f 0) 
	 (delay 1 (set pc disp26))
	 (if (eq sys-sr-f 1)
	     ; the delay slot is executed always, but when we're not branching
	     ; the PC is not updated to skip it, so we execute it twice. To
	     ; avoid that, we'll step over it here, but really it's executed
	     (delay 1 (set pc (add pc 8)))))
     ()
)

(dni l-bf "branch if condition bit is set (pc relative iaddr)"
     ; This function may not be in delay slot
     ((MACH ORBIS32-MACHS) NOT-IN-DELAY-SLOT)

     "l.bf ${disp26}"
     (+ OPC_BF disp26)

     ; We execute the delay slot before doin' the real branch
     (if (eq sys-sr-f 1) 
	 (delay 1 (set pc disp26))
	 (if (eq sys-sr-f 0)
	     ; the delay slot is executed always, but when we're not branching
	     ; the PC is not updated to skip it, so we execute it twice. To
	     ; avoid that, we'll step over it here, but really it's executed
	     (delay 1 (set pc (add pc 8)))))
     ()
)

(dni l-trap "trap (exception)"
     ((MACH ORBIS32-MACHS))
     "l.trap ${uimm16}"
     (+ OPC_SYSTRAPSYNCS OPC_SYSTRAPSYNCS_TRAP (f-resv-20-5 0) uimm16)
     ; Do exception entry handling in C function, PC set based on SR state
     (set pc (c-call WI "@arch@_cpu_exception_entry" 14 pc ))
     ()
)


(dni l-sys "syscall (exception)"
     ; This function may not be in delay slot
     ((MACH ORBIS32-MACHS) NOT-IN-DELAY-SLOT)

     "l.sys ${uimm16}"
     (+ OPC_SYSTRAPSYNCS OPC_SYSTRAPSYNCS_SYSCALL (f-resv-20-5 0) uimm16)
     ; Do exception entry handling in C function, PC set based on SR state
     (set pc (c-call WI "@arch@_cpu_exception_entry" #xC pc ))

     ()
)


(dni l-rfe "return from exception"
     ; This function may not be in delay slot
     ((MACH ORBIS32-MACHS) NOT-IN-DELAY-SLOT)

     "l.rfe"
     (+ OPC_RFE (f-resv-25-26 0))
     (sequence ()
	       ; Set SR to whatever is in ESR
               (set WI sys-sr sys-esr0)
	       ; Set PC to whatever is in EPCR
               (set IAI pc sys-epcr0)
               )
     ()
)


; Misc instructions

; l.nop with immediate must be first so it handles all l.nops in sim
(dni l-nop-imm "nop uimm16"
     ((MACH ORBIS32-MACHS))
     "l.nop ${uimm16}"
     (+ OPC_NOP (f-op-25-2 #x1) (f-resv-23-8 0) uimm16)
     (c-call VOID "@cpu@_nop_handler" uimm16 )
     ()
)

(dni l-nop "nop"
     ((MACH ORBIS32-MACHS))
     "l.nop"
     (+ OPC_NOP (f-op-25-2 #x1) (f-resv-23-8 0) uimm16)
     (nop)
     ()
)

(dni l-movhi "movhi reg/uimm16"
     ((MACH ORBIS32-MACHS))
     "l.movhi $rD,$uimm16"
     (+ OPC_MOVHIMACRC rD (f-resv-20-4 0) OPC_MOVHIMACRC_MOVHI uimm16)
     (set rD (sll WI uimm16 (const 16)))
     ()
)

(dni l-macrc "macrc reg"
     ((MACH ORBIS32-MACHS))
     "l.macrc $rD"
     (+ OPC_MOVHIMACRC rD (f-resv-20-4 0) OPC_MOVHIMACRC_MACRC (f-uimm16 0))
     (parallel ()
               (set rD mac-maclo)
               (set mac-maclo 0)
               (set mac-machi 0)
               )
     ()
     )


; System releated instructions

(dni l-mfspr "mfspr"
     ((MACH ORBIS32-MACHS))
     "l.mfspr $rD,$rA,${uimm16}"
     (+ OPC_MFSPR rD rA uimm16)
     (set rD (c-call WI "@cpu@_h_spr_get_handler" (or rA uimm16)))
     ()
)

(dni l-mtspr "mtspr"
     ((MACH ORBIS32-MACHS))
     "l.mtspr $rA,$rB,${uimm16-split}"
     (+ OPC_MTSPR rA rB uimm16-split )
     (c-call VOID "@cpu@_h_spr_set_handler" (or rA uimm16-split) rB)
     ()
)


; Load instructions

(dni l-lwz "l.lwz reg/simm16(reg)"
     ((MACH ORBIS32-MACHS))
     "l.lwz $rD,${simm16}($rA)"
     (+ OPC_LWZ rD rA simm16)
     (set rD (zext WI (mem SI (add rA simm16))))
     ()
)


(dni l-lws "l.lws reg/simm16(reg)"
     ((MACH ORBIS32-MACHS))
     "l.lws $rD,${simm16}($rA)"
     (+ OPC_LWS rD rA simm16)
     (set rD (ext WI (mem SI (add rA simm16))))
     ()
)

(dni l-lbz "l.lbz reg/simm16(reg)"
     ((MACH ORBIS32-MACHS))
     "l.lbz $rD,${simm16}($rA)"
     (+ OPC_LBZ rD rA simm16)
     (set rD (zext WI (mem QI (add rA simm16))))
     ()
)

(dni l-lbs "l.lbz reg/simm16(reg)"
     ((MACH ORBIS32-MACHS))
     "l.lbs $rD,${simm16}($rA)"
     (+ OPC_LBS rD rA simm16)
     (set rD (ext WI (mem QI (add rA simm16))))
     ()
)

(dni l-lhz "l.lhz reg/simm16(reg)"
     ((MACH ORBIS32-MACHS))
     "l.lhz $rD,${simm16}($rA)"
     (+ OPC_LHZ rD simm16 rA)
     (set rD (zext WI (mem HI (add rA simm16))))
     ()
)

(dni l-lhs "l.lhs reg/simm16(reg)"
     ((MACH ORBIS32-MACHS))
     "l.lhs $rD,${simm16}($rA)"
     (+ OPC_LHS rD rA simm16)
     (set rD (ext WI (mem HI (add rA simm16))))
     ()
)


; Store instructions

(define-pmacro (store-insn mnemonic opc-op mode-op)
  (begin
     (dni (.sym l- mnemonic)
          (.str "l." mnemonic " simm16(reg)/reg")
          ((MACH ORBIS32-MACHS))
          (.str "l." mnemonic " ${simm16-split}($rA),$rB")
          (+ opc-op rB rD simm16-split)
          (set (mem mode-op (add rA simm16-split)) rB)
          ()
     )
   )
)

(store-insn sw OPC_SW SI)
(store-insn sb OPC_SB QI)
(store-insn sh OPC_SH HI)



; Shift and rotate instructions

(define-pmacro (shift-insn mnemonic opc-shrots-op)
  (begin
     (dni (.sym l- mnemonic)
          (.str "l." mnemonic " reg/reg/reg")
          ((MACH ORBIS32-MACHS))
          (.str "l." mnemonic " $rD,$rA,$rB")
          (+ OPC_ALU rD rA rB (f-resv-10-3 0) opc-shrots-op (f-resv-5-2 0) 
	     OPC_ALU_REGREG_SHROT )
          (set rD (mnemonic rA rB))
          ()
     )
     (dni (.sym l- mnemonic "i")
          (.str "l." mnemonic " reg/reg/uimm6")
          ((MACH ORBIS32-MACHS))
          (.str "l." mnemonic "i $rD,$rA,${uimm6}")
          (+ OPC_SHROTI rD rA (f-resv-15-8 0) opc-shrots-op uimm6)
          (set rD (mnemonic rA uimm6))
          ()
     )
   )
)

(shift-insn sll OPC_SHROTS_SLL)
(shift-insn srl OPC_SHROTS_SRL)
(shift-insn sra OPC_SHROTS_SRA)
(shift-insn ror OPC_SHROTS_ROR)


; Arithmetic insns

; ALU op macro
(define-pmacro (alu-insn mnemonic opc-alu)
  (begin
     (dni (.sym l- mnemonic)
          (.str "l." mnemonic " reg/reg/reg")
          ((MACH ORBIS32-MACHS))
          (.str "l." mnemonic " $rD,$rA,$rB")
          (+ OPC_ALU rD rA rB (f-resv-10-7 0) opc-alu)
          (set rD (mnemonic rA rB))
          ()
     )
  )
)

(dni (l-add) "l.add reg/reg/reg"
          ((MACH ORBIS32-MACHS))
          ("l.add $rD,$rA,$rB")
          (+ OPC_ALU rD rA rB (f-resv-10-7 #x00) OPC_ALU_REGREG_ADD)
          (parallel ()
                    (set rD (add WI rA rB))
                    (set sys-sr-ov (addc-oflag WI rA rB 0))
                    (set sys-sr-cy (addc-cflag WI rA rB 0))
                    )
          ()
)

(dni (l-sub) "l.sub reg/reg/reg"
          ((MACH ORBIS32-MACHS))
          ("l.sub $rD,$rA,$rB")
          (+ OPC_ALU rD rA rB (f-resv-10-7 #x00) OPC_ALU_REGREG_SUB)
          (parallel ()
                    (set rD (sub WI rA rB))
                    (set sys-sr-ov (subc-oflag WI rA rB 0))
                    (set sys-sr-cy (subc-cflag WI rA rB 0))
                    )
          ()
)

(alu-insn and OPC_ALU_REGREG_AND)
(alu-insn or  OPC_ALU_REGREG_OR )
(alu-insn xor OPC_ALU_REGREG_XOR)

(dni (l-addc) "l.addc reg/reg/reg"
          ((MACH ORBIS32-MACHS))
          ("l.addc $rD,$rA,$rB")
          (+ OPC_ALU rD rA rB (f-resv-10-7 #x00) OPC_ALU_REGREG_ADDC)
          (parallel ()
                    (set rD (addc WI rA rB sys-sr-cy))
                    (set sys-sr-ov (addc-oflag WI rA rB sys-sr-cy))
                    (set sys-sr-cy (addc-cflag WI rA rB sys-sr-cy))
                    )
          ()
)

(dni (l-mul) "l.mul reg/reg/reg"
          ((MACH ORBIS32-MACHS))
          ("l.mul $rD,$rA,$rB")
          (+ OPC_ALU rD rA rB (f-resv-10-7 #x30) OPC_ALU_REGREG_MUL)
          (sequence ()
                    (set rD (mul WI rA rB))
                    ; I'm assuming carry never is 1?  Not specified in or1k manual
                    (set sys-sr-cy 0)
                    ; dirty way to check for overflow
                    (set sys-sr-ov (andif (ne rA 0) (ne (div WI rD rA) rB)))
                    )
          ()
)

(dni (l-mulu) "l.mulu reg/reg/reg"
          ((MACH ORBIS32-MACHS))
          ("l.mulu $rD,$rA,$rB")
          (+ OPC_ALU rD rA rB (f-resv-10-7 #x30) OPC_ALU_REGREG_MULU)
          (sequence ()
                    (set rD (mul UWI rA rB))
                    (set sys-sr-cy 0)
                    (set sys-sr-ov (andif (ne rA 0) (ne (div UWI rD rA) rB)))
                    )
          ()
)

(dni l-div "divide (signed)"
          ((MACH ORBIS32-MACHS))
          "l.div $rD,$rA,$rB"
          (+ OPC_ALU rD rA rB (f-resv-10-7 #x30) OPC_ALU_REGREG_DIV)
          (if (ne rB 0)
              (sequence ()
                        (set rD (div WI rA rB))
                        (set sys-sr-cy 0)
                        (set sys-sr-ov 0)
                        )
              (sequence ()
                        ; carry flag is set, but not sure what is written to rD
                        ; (probably nothing)
                        (set sys-sr-cy 1)
                        )
              )
          ()
)

(dni l-divu "divide (unsigned)"
          ((MACH ORBIS32-MACHS))
          "l.divu $rD,$rA,$rB"
          (+ OPC_ALU rD rA rB (f-resv-10-7 #x30) OPC_ALU_REGREG_DIVU)
          (if (ne rB 0)
              (sequence ()
                        (set rD (div UWI rA rB))
                        (set sys-sr-cy 0)
                        (set sys-sr-ov 0)
                        )
              (sequence ()
                        (set sys-sr-cy 1)
                        )
              )
          ()
)

(dni l-ff1 "find first '1'"
          ((MACH ORBIS32-MACHS))
          "l.ff1 $rD,$rA"
          (+ OPC_ALU rD rA rB (f-resv-10-7 #x00) OPC_ALU_REGREG_FFL1)
          (set rD (c-call WI "@cpu@_h_ff1" rA))
          ()
)

(dni l-fl1 "find last '1'"
          ((MACH ORBIS32-MACHS))
          "l.fl1 $rD,$rA"
          (+ OPC_ALU rD rA rB (f-resv-10-7 #x10) OPC_ALU_REGREG_FFL1)
          (set rD (c-call WI "@cpu@_h_fl1" rA))
          ()
)


(define-pmacro (alu-insn-simm  mnemonic insn-opc)
  (begin
      (dni (.sym l- mnemonic "i")
          (.str "l." mnemonic " reg/reg/simm16")
          ((MACH ORBIS32-MACHS))
          (.str "l." mnemonic "i $rD,$rA,$simm16")
          (+ insn-opc rD rA simm16)
          (set rD (mnemonic rA (ext WI (trunc HI simm16))))
          ()
     )
   )
)

(define-pmacro (alu-insn-uimm  mnemonic insn-opc)
  (begin
      (dni (.sym l- mnemonic "i")
          (.str "l." mnemonic " reg/reg/uimm16")
          ((MACH ORBIS32-MACHS))
          (.str "l." mnemonic "i $rD,$rA,$uimm16")
          (+ insn-opc rD rA uimm16)
          (set rD (mnemonic rA (zext WI (trunc HI uimm16))))
          ()
     )
   )
)

(alu-insn-uimm and OPC_ANDI )
(alu-insn-uimm or  OPC_ORI  )
(alu-insn-simm xor OPC_XORI )

(dni (l-addi) "l.addi reg/reg/simm16"
          ((MACH ORBIS32-MACHS))
          ("l.addi $rD,$rA,$simm16")
          (+ OPC_ADDI rD rA simm16)
          (parallel ()
                    (set rD (add WI rA (ext WI (trunc HI simm16))))
                    (set sys-sr-ov (addc-oflag WI rA (ext WI (trunc HI simm16)) 0))
                    (set sys-sr-cy (addc-cflag WI rA (ext WI (trunc HI simm16)) 0))
                    )
          ()
)

(dni (l-addic)
     ("l.addic reg/reg/simm16")
     ((MACH ORBIS32-MACHS))
     ("l.addic $rD,$rA,$simm16")
     (+ OPC_ADDIC rD rA simm16)
     (parallel ()
               (set rD (addc WI rA (ext WI (trunc HI simm16)) sys-sr-cy))
               (set sys-sr-ov (add-oflag WI rA (ext WI (trunc HI simm16)) sys-sr-cy))
               (set sys-sr-cy (add-cflag WI rA (ext WI (trunc HI simm16)) sys-sr-cy))
               )
     ()
)

(dni (l-muli)
     "l.muli reg/reg/simm16"
     ((MACH ORBIS32-MACHS))
     ("l.muli $rD,$rA,$simm16")
     (+ OPC_MULI rD rA simm16)
     (sequence ()
               (set rD (mul WI rA (ext WI (trunc HI simm16))))
               (set sys-sr-cy 0)
               (set sys-sr-ov (andif (ne rA 0) (ne (div WI rD rA) (ext WI (trunc HI simm16)))))
               )
     ()
     )

(define-pmacro (extbh-insn mnemonic insn-opc extop truncmode)
  (begin
    (dni (.sym l- mnemonic)
         (.str "l." mnemonic " reg/reg")
         ((MACH ORBIS32-MACHS))
         (.str "l." mnemonic " $rD,$rA")
         (+ OPC_ALU rD rA (f-resv-15-6 0) insn-opc (f-resv-5-2 0) OPC_ALU_REGREG_EXTBH)
         (set rD (extop WI (trunc truncmode rA)))
         ()
         )
    )
  )

(extbh-insn exths OPC_EXTBHS_EXTHS ext HI)
(extbh-insn extbs OPC_EXTBHS_EXTBS ext QI)
(extbh-insn exthz OPC_EXTBHS_EXTHZ zext HI)
(extbh-insn extbz OPC_EXTBHS_EXTBZ zext QI)

(define-pmacro (extw-insn mnemonic insn-opc extop truncmode)
  (begin
    (dni (.sym l- mnemonic)
         (.str "l." mnemonic " reg/reg")
         ((MACH ORBIS32-MACHS))
         (.str "l." mnemonic " $rD,$rA")
         (+ OPC_ALU rD rA (f-resv-15-6 0) insn-opc (f-resv-5-2 0) OPC_ALU_REGREG_EXTW)
         (set rD (extop WI (trunc truncmode rA)))
         ()
         )
    )
  )

(extw-insn extws OPC_EXTWS_EXTWS ext SI)
(extw-insn extwz OPC_EXTWS_EXTWZ zext SI)

(dni l-cmov
     "l.cmov reg/reg/reg"
     ((MACH ORBIS32-MACHS))
     "l.cmov $rD,$rA,$rB"
     (+ OPC_ALU rD rA rB (f-resv-10-1 0) (f-op-9-2 0) (f-resv-7-4 0) OPC_ALU_REGREG_CMOV)
     (if sys-sr-f
         (set WI rD rA)
         (set WI rD rB)
         )
     ()
     )

; Compare instructions

; Register compare signed
(define-pmacro (sf-insn-sr opc-sf sem-op)
  (begin
     (dni (.sym l- "sf" (.sym sem-op "s"))
          (.str "l.sf" (.str sem-op) "s reg/reg")
          ((MACH ORBIS32-MACHS))
          (.str "l.sf" (.str sem-op) "s $rA,$rB")
          (+ OPC_SF opc-sf rA rB (f-resv-10-11 0))
          (set sys-sr-f (sem-op WI rA rB))
          ()
     )
  )
)

; Register compare unsigned
(define-pmacro (sf-insn-ur opc-sf sem-op)
  (begin
     (dni (.sym l- "sf" (.sym sem-op "u"))
          (.str "l." (.str sem-op) "u reg/reg")
          ((MACH ORBIS32-MACHS))
          (.str "l.sf" (.str sem-op) "u $rA,$rB")
          (+ OPC_SF opc-sf rA rB (f-resv-10-11 0))
          (set sys-sr-f (sem-op UWI rA rB))
          ()
     )
  )
)

; Immediate compare signed
(define-pmacro (sf-insn-si opc-sf sem-op)
  (begin
     (dni (.sym l- "sf" (.sym sem-op "si"))
          (.str "l." (.str sem-op) "si reg/simm16")
          ((MACH ORBIS32-MACHS))
          (.str "l.sf" (.str sem-op) "si $rA,${simm16}")
          (+ OPC_SFI opc-sf rA simm16)
          (set sys-sr-f (sem-op WI rA simm16))
          ()
     )
  )
)

; Immediate compare unsigned
(define-pmacro (sf-insn-ui opc-sf sem-op)
  (begin
     (dni (.sym l- "sf" (.sym sem-op "ui"))
          (.str "l." (.str sem-op) "ui reg/uimm16")
          ((MACH ORBIS32-MACHS))
          (.str "l.sf" (.str sem-op) "ui $rA,$uimm16")
          (+ OPC_SFI opc-sf rA uimm16)
          (set sys-sr-f (sem-op UWI rA (ext WI (trunc HI uimm16))))
          ()
     )
  )
)

; Equality Compare
(define-pmacro (sf-insn opc-sf sem-op)
  (begin
     (dni (.sym l- "sf" sem-op)
          (.str "l." (.str sem-op) " reg/reg")
          ((MACH ORBIS32-MACHS))
          (.str "l.sf" (.str sem-op) " $rA,$rB")
          (+ OPC_SF opc-sf rA rB (f-resv-10-11 0))
          (set sys-sr-f (sem-op UWI rA rB))
          ()
     )
     (dni (.sym l- "sf" (.sym sem-op "i"))
          (.str "l.sf" (.str sem-op) "i reg/simm16")
          ((MACH ORBIS32-MACHS))
          (.str "l.sf" (.str sem-op) "i $rA,$simm16")
          (+ OPC_SFI opc-sf rA simm16)
          (set sys-sr-f (sem-op UWI rA (ext WI (trunc HI simm16))))
          ()
     )
   )
)


(sf-insn-ur OPC_SF_GTU gt)
(sf-insn-ur OPC_SF_GEU ge)
(sf-insn-ur OPC_SF_LTU lt)
(sf-insn-ur OPC_SF_LEU le)

(sf-insn-sr OPC_SF_GTS gt)
(sf-insn-sr OPC_SF_GES ge)
(sf-insn-sr OPC_SF_LTS lt)
(sf-insn-sr OPC_SF_LES le)

(sf-insn-ui OPC_SF_GTU gt)
(sf-insn-ui OPC_SF_GEU ge)
(sf-insn-ui OPC_SF_LTU lt)
(sf-insn-ui OPC_SF_LEU le)

(sf-insn-si OPC_SF_GTS gt)
(sf-insn-si OPC_SF_GES ge)
(sf-insn-si OPC_SF_LTS lt)
(sf-insn-si OPC_SF_LES le)

(sf-insn    OPC_SF_EQ  eq)
(sf-insn    OPC_SF_NEQ ne)

(dni l-mac
     "l.mac reg/reg"
     ((MACH ORBIS32-MACHS))
     "l.mac $rA,$rB"
     (+  OPC_MAC (f-op-25-5 0) rA rB (f-resv-10-7 0) OPC_MAC_MAC)
     (sequence ((WI prod))
               (set WI prod (mul WI rA rB))
               (set DI (join DI SI mac-machi mac-maclo) (add (join DI SI mac-machi mac-maclo) (ext DI prod)))
               )
     ()
     )

(dni l-msb
     "l.msb reg/reg"
     ((MACH ORBIS32-MACHS))
     "l.msb $rA,$rB"
     (+  OPC_MAC (f-op-25-5 0) rA rB (f-resv-10-7 0) OPC_MAC_MSB)
     (sequence ((WI prod))
               (set WI prod (mul WI rA rB))
               (set DI (join DI SI mac-machi mac-maclo) (sub (join DI SI mac-machi mac-maclo) (ext DI prod)))
               )
     ()
     )

(dni l-maci
     "l.maci reg/simm16"
     ((MACH ORBIS32-MACHS))
     "l.maci $rA,${simm16}"
     (+ OPC_MACI (f-resv-20-5 0) rA simm16)
     (sequence ((WI prod))
               (set WI prod (mul WI (ext WI simm16-split) rA))
               (set DI (join DI SI mac-machi mac-maclo) (add (join DI SI mac-machi mac-maclo) (ext DI prod)))
               )
     ()
     )
